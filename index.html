<!doctype html>
<!-- Build: 2025-11-27 Force Redeploy -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WH15P3R â€“ Ephemeral Post-Quantum Secure Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg-main: #02030a;
      --accent-teal: #33f0d4;
      --accent-amber: #ffb347;
      --danger-red: #ff4a4a;
      --text-main: #f5f7ff;
      --text-muted: #9aa1c3;
      --glass-bg: rgba(10, 10, 18, 0.82);
      --border-glass: rgba(118, 255, 230, 0.18);
      --radius-lg: 20px;
      --radius-pill: 999px;
      --shadow-soft: 0 22px 60px rgba(0, 0, 0, 0.65);
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", sans-serif;
      --font-mono: "JetBrains Mono", "SF Mono", ui-monospace, Menlo, monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--font-sans);
      color: var(--text-main);
      background:
        radial-gradient(circle at top, #101633 0, transparent 55%),
        radial-gradient(circle at bottom, #050915 0, transparent 60%),
        var(--bg-main);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 24px;
    }

    .noise-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.12;
      mix-blend-mode: soft-light;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.5'/%3E%3C/svg%3E");
      z-index: 1;
    }

    .app-shell {
      position: relative;
      z-index: 2;
      max-width: 1120px;
      width: 100%;
      margin: 0 auto;
    }

    .glass-panel {
      background: var(--glass-bg);
      border-radius: 28px;
      border: 1px solid var(--border-glass);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(24px);
      padding: 22px 26px 26px;
    }

    header.app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 18px;
    }

    .logo-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .logo-title {
      letter-spacing: 0.32em;
      font-size: 14px;
      text-transform: uppercase;
      color: var(--accent-teal);
    }

    .logo-subtitle {
      font-size: 13px;
      color: var(--text-muted);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 14px;
      border-radius: var(--radius-pill);
      background: rgba(10, 16, 40, 0.9);
      border: 1px solid rgba(137, 167, 255, 0.4);
      font-family: var(--font-mono);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      white-space: nowrap;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #a3a8c0;
      box-shadow: 0 0 0 0 rgba(51, 240, 212, 0.65);
      transition: background 0.2s ease, box-shadow 0.3s ease;
    }

    .status-pill.pq-active {
      border-color: rgba(51, 240, 212, 0.85);
      background: radial-gradient(circle at top left, rgba(51, 240, 212, 0.18), rgba(6, 12, 28, 0.96));
    }

    .status-pill.pq-active .status-indicator {
      background: var(--accent-teal);
      box-shadow: 0 0 14px 2px rgba(51, 240, 212, 0.8);
    }

    .status-label-main {
      font-weight: 600;
    }

    .status-label-sub {
      opacity: 0.75;
      font-size: 10px;
    }

    .status-label-sub span {
      color: var(--accent-teal);
    }

    .grid-main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 22px;
      margin-bottom: 22px;
    }

    @media (max-width: 768px) {
      .glass-panel {
        padding: 18px 16px 18px;
      }

      header.app-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .grid-main {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      border-radius: 20px;
      border: 1px solid rgba(159, 191, 255, 0.16);
      background: radial-gradient(circle at top left, rgba(26, 46, 98, 0.32), rgba(5, 10, 22, 0.95));
      padding: 18px 18px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 2px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .card-tag {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-family: var(--font-mono);
      padding: 4px 9px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(130, 161, 255, 0.6);
      color: var(--text-muted);
    }

    .card-tag strong {
      color: var(--accent-teal);
    }

    .card-body p {
      margin: 0;
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .mode-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 4px;
    }

    .mode-button {
      flex: 1 1 90px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(139, 168, 255, 0.5);
      background: rgba(9, 14, 32, 0.95);
      color: var(--text-main);
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease, border 0.12s ease, background 0.12s ease;
    }

    .mode-button span.icon {
      font-size: 14px;
      opacity: 0.9;
    }

    .mode-button.selected {
      background: linear-gradient(135deg, #1bdac0, #32b6ff);
      border-color: rgba(49, 220, 230, 0.9);
      color: #020512;
      font-weight: 600;
    }

    .mode-button.disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .mode-button:not(.disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.6);
    }

    .mode-button:not(.disabled):active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .code-input-row {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .code-input-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .code-input-wrapper {
      display: flex;
      gap: 8px;
    }

    .code-input {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(141, 170, 255, 0.55);
      background: rgba(1, 4, 16, 0.9);
      padding: 10px 12px;
      color: var(--text-main);
      font-family: var(--font-mono);
      font-size: 13px;
      outline: none;
    }

    .code-input::placeholder {
      color: rgba(143, 160, 210, 0.6);
    }

    .copy-button {
      border-radius: 12px;
      border: 1px solid rgba(89, 135, 255, 0.9);
      background: rgba(11, 24, 64, 0.96);
      color: var(--text-main);
      font-size: 12px;
      padding: 8px 11px;
      cursor: pointer;
      white-space: nowrap;
      min-width: 80px;
      transition: all 0.2s ease;
    }

    .copy-button:hover:not(.disabled) {
      background: rgba(89, 135, 255, 0.2);
      transform: translateY(-1px);
    }

    .copy-button.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .hint-text {
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .hint-text strong {
      color: var(--accent-teal);
    }

    .security-strip {
      margin-top: 4px;
      padding-top: 14px;
      border-top: 1px solid rgba(115, 144, 230, 0.32);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .security-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      flex: 1 1 auto;
    }

    .security-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      padding: 5px 10px;
      border-radius: 999px;
      background: rgba(8, 14, 30, 0.96);
      border: 1px solid rgba(125, 150, 230, 0.5);
      color: var(--text-muted);
    }

    .security-badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #8f95b8;
    }

    .security-item.ok .security-badge-dot {
      background: var(--accent-teal);
    }

    .security-item.warn .security-badge-dot {
      background: var(--accent-amber);
    }

    .security-item.danger .security-badge-dot {
      background: var(--danger-red);
    }

    .security-item span.label {
      font-family: var(--font-mono);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 10px;
    }

    .security-item span.detail {
      opacity: 0.8;
    }

    .guide-link-btn {
      border-radius: 999px;
      border: 1px solid rgba(142, 172, 255, 0.6);
      background: rgba(10, 16, 40, 0.9);
      padding: 6px 14px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      cursor: pointer;
      white-space: nowrap;
      text-decoration: none;
      display: inline-block;
      transition: all 0.2s ease;
    }

    .guide-link-btn:hover {
      background: rgba(142, 172, 255, 0.2);
      border-color: var(--accent-teal);
      color: var(--accent-teal);
    }

    .vpn-confirm-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 8px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(10, 16, 40, 0.5);
      border: 1px solid rgba(255, 179, 71, 0.3);
    }

    .vpn-confirm-row input[type="checkbox"] {
      margin-top: 2px;
      accent-color: var(--accent-teal);
      cursor: pointer;
    }

    .vpn-confirm-row label {
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
      line-height: 1.5;
    }

    .vpn-confirm-row label strong {
      color: var(--accent-amber);
    }

    .pq-blocker {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(20, 20, 34, 0.98), rgba(1, 2, 5, 0.98));
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      backdrop-filter: blur(10px);
    }

    .pq-blocker.active {
      display: flex;
    }

    .pq-blocker-inner {
      max-width: 520px;
      width: 100%;
      padding: 22px 22px 20px;
      border-radius: 24px;
      background: rgba(6, 8, 18, 0.96);
      border: 1px solid rgba(255, 103, 103, 0.7);
      box-shadow: 0 26px 80px rgba(0, 0, 0, 0.85);
    }

    .pq-blocker-title {
      font-size: 17px;
      font-weight: 600;
      margin-bottom: 6px;
      color: #ffecec;
    }

    .pq-blocker-body {
      font-size: 13px;
      color: #ffcfd0;
      margin-bottom: 12px;
      line-height: 1.6;
    }

    .pq-blocker-body strong {
      color: #ffe8a3;
    }

    .pq-blocker-list {
      font-size: 13px;
      color: #ffd6d6;
      padding-left: 16px;
      margin: 6px 0 12px;
      line-height: 1.6;
    }

    .pq-blocker-list li {
      margin-bottom: 4px;
    }

    .pq-blocker-footer {
      font-size: 12px;
      color: #ffebeb;
      opacity: 0.9;
    }

    /* Chat interface styles */
    .chat-interface {
      display: none;
      margin-top: 20px;
    }

    .chat-interface.active {
      display: block;
    }

    .messages-container {
      border-radius: 16px;
      border: 1px solid rgba(159, 191, 255, 0.2);
      background: rgba(5, 8, 18, 0.8);
      padding: 16px;
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 12px;
    }

    .message {
      margin-bottom: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.sent {
      background: rgba(74, 158, 255, 0.15);
      border-left: 3px solid #4a9eff;
      margin-left: 20px;
    }

    .message.received {
      background: rgba(51, 240, 212, 0.1);
      border-left: 3px solid var(--accent-teal);
      margin-right: 20px;
    }

    .message.system {
      background: rgba(255, 179, 71, 0.08);
      border-left: 3px solid var(--accent-amber);
      text-align: center;
      margin-left: 0;
      margin-right: 0;
    }

    .message-meta {
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 4px;
      font-family: var(--font-mono);
    }

    .message-text {
      font-size: 13px;
      color: var(--text-main);
      line-height: 1.5;
      word-wrap: break-word;
    }

    .input-area {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .input-area input {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(141, 170, 255, 0.4);
      background: rgba(1, 4, 16, 0.9);
      padding: 10px 14px;
      color: var(--text-main);
      font-family: var(--font-sans);
      font-size: 13px;
      outline: none;
    }

    .input-area input:focus {
      border-color: var(--accent-teal);
      box-shadow: 0 0 0 2px rgba(51, 240, 212, 0.1);
    }

    .input-area button {
      border-radius: 12px;
      border: 1px solid rgba(89, 135, 255, 0.6);
      background: rgba(11, 24, 64, 0.96);
      color: var(--text-main);
      font-size: 12px;
      padding: 10px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: var(--font-mono);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .input-area button:hover {
      background: rgba(89, 135, 255, 0.3);
      transform: translateY(-1px);
    }

    .input-area button.end-btn {
      border-color: rgba(255, 74, 74, 0.6);
      background: rgba(40, 10, 10, 0.96);
    }

    .input-area button.end-btn:hover {
      background: rgba(255, 74, 74, 0.2);
      border-color: var(--danger-red);
    }

    /* Media (video/voice) styles */
    .media-container {
      display: none;
      margin-top: 20px;
    }

    .media-container.active {
      display: block;
    }

    .video-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    @media (max-width: 768px) {
      .video-grid {
        grid-template-columns: 1fr;
      }
    }

    .video-box {
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(159, 191, 255, 0.2);
      background: #000;
      overflow: hidden;
      aspect-ratio: 16 / 9;
    }

    .video-box.remote {
      border-color: var(--accent-teal);
      box-shadow: 0 0 20px rgba(51, 240, 212, 0.2);
    }

    .video-box video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .video-label {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: var(--text-main);
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 10px;
      font-family: var(--font-mono);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .media-controls-row {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .media-control-btn {
      border-radius: 12px;
      border: 1px solid rgba(139, 168, 255, 0.5);
      background: rgba(9, 14, 32, 0.95);
      color: var(--text-main);
      font-size: 12px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: var(--font-mono);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .media-control-btn:hover {
      background: rgba(139, 168, 255, 0.2);
      transform: translateY(-1px);
    }

    .media-control-btn.active {
      border-color: var(--accent-teal);
      color: var(--accent-teal);
    }

    .media-control-btn.muted {
      border-color: var(--danger-red);
      color: var(--danger-red);
    }

    .waiting-message {
      text-align: center;
      padding: 20px;
      font-size: 13px;
      color: var(--accent-amber);
      font-family: var(--font-mono);
      letter-spacing: 0.08em;
    }
  </style>

</head>
<body>
<div class="noise-overlay"></div>

<div class="pq-blocker" id="pqBlocker">
  <div class="pq-blocker-inner">
    <div class="pq-blocker-title">âš  Post-quantum browser required</div>
    <div class="pq-blocker-body">
      WH15P3R only operates when your browser supports <strong>post-quantum DTLS 1.3</strong>.
      Your current browser or version cannot provide the required level of protection.
    </div>
    <ul class="pq-blocker-list">
      <li>Use <strong>Brave</strong>, <strong>Tor Browser</strong>, <strong>Chrome 142+</strong>, <strong>Edge 142+</strong> or the latest <strong>Firefox</strong>.</li>
      <li>Connect through a reputable <strong>VPN</strong> or <strong>Tor</strong> before returning.</li>
      <li>Never use work internet for sensitive conversations.</li>
    </ul>
    <div class="pq-blocker-footer">
      Once you are using a supported browser through VPN/Tor, reload this page to continue.
    </div>
  </div>
</div>

<div class="app-shell">
  <div class="glass-panel">
    <header class="app-header">
      <div class="logo-block">
        <div class="logo-title">WH15P3R</div>
        <div class="logo-subtitle">Ephemeral Â· Encrypted Â· Anonymous Â· Post-Quantum Ready</div>
      </div>
      <div class="status-pill" id="pqStatusPill">
        <span class="status-indicator"></span>
        <div>
          <div class="status-label-main" id="statusMain">Q STATUS: PQ OFFLINE</div>
          <div class="status-label-sub" id="statusSub">
            Awaiting <span>post-quantum secure channel</span>
          </div>
        </div>
      </div>
    </header>

<!-- Setup Interface -->
<div id="setupInterface">
  <div class="grid-main">
    <!-- Start session card -->
    <section class="card">
      <div class="card-header">
        <div class="card-title">Establish a secure session</div>
        <div class="card-tag"><strong>Step 1</strong> Â· New session</div>
      </div>
      <div class="card-body">
        <p>
          Choose how you want to communicate. A unique session code will be generated and
          protected with post-quantum cryptography when available.
        </p>

        <div class="mode-row">
          <button class="mode-button selected" id="modeText" onclick="selectMode('text')">
            <span class="icon">ðŸ’¬</span> Text only
          </button>
          <button class="mode-button" id="modeVoice" onclick="selectMode('voice')">
            <span class="icon">ðŸŽ™</span> Voice
          </button>
          <button class="mode-button" id="modeVideo" onclick="selectMode('video')">
            <span class="icon">ðŸ“¹</span> Video
          </button>
        </div>

        <div class="code-input-row" id="sessionCodeRow" style="display: none;">
          <div class="code-input-label">
            Session code for your contact (share verbally or over a separate channel):
          </div>
          <div class="code-input-wrapper">
            <input
              id="sessionCodeGenerated"
              class="code-input"
              type="text"
              readonly
              placeholder="Generating..."
            />
            <button class="copy-button disabled" id="btnCopyCode" onclick="copySessionCode()">Copy</button>
          </div>
          <div class="hint-text">
            Confirm this code <strong>out-of-band</strong> (phone call or in person) to prevent
            man-in-the-middle attacks.
          </div>
          <div class="waiting-message" id="waitingMessage">âŸ³ Waiting for peer connection...</div>
        </div>

        <div class="vpn-confirm-row">
          <input type="checkbox" id="vpnConfirm" onchange="updateControlsForVpn()" />
          <label for="vpnConfirm">
            I confirm I am connected through a <strong>VPN or Tor</strong>, and I am
            <strong>not using work internet</strong>.
          </label>
        </div>

        <div style="margin-top: 12px;">
          <button class="mode-button disabled" id="btnStartSession" onclick="createSession()">
            <span class="icon">ðŸ”’</span> Start Session
          </button>
        </div>
      </div>
    </section>

    <!-- Join session card -->
    <section class="card">
      <div class="card-header">
        <div class="card-title">Join a secure session</div>
        <div class="card-tag"><strong>Step 2</strong> Â· Join</div>
      </div>
      <div class="card-body">
        <p>
          Paste the session code you received from your contact. You will only be able to join
          when your browser is post-quantum capable and you confirm VPN/Tor use.
        </p>

        <div class="code-input-row">
          <div class="code-input-label">Enter session code to join:</div>
          <div class="code-input-wrapper">
            <input
              id="sessionCodeInput"
              class="code-input"
              type="text"
              placeholder="Paste session code here"
            />
            <button class="mode-button disabled" id="btnJoinSession" onclick="joinSession()">
              Join session
            </button>
          </div>
        </div>

        <div class="hint-text" id="browserHint">
          Using Brave or Tor is recommended. In other browsers, clear history and cache when
          your session ends.
        </div>
      </div>
    </section>
  </div>

  <!-- Security strip -->
  <div class="security-strip">
    <div class="security-items">
      <div class="security-item warn" id="secBrowser">
        <span class="security-badge-dot"></span>
        <span class="label">Browser</span>
        <span class="detail" id="secBrowserDetail">PQ capability checkingâ€¦</span>
      </div>
      <div class="security-item warn" id="secVpn">
        <span class="security-badge-dot"></span>
        <span class="label">VPN / Tor</span>
        <span class="detail" id="secVpnDetail">Pending confirmation</span>
      </div>
      <div class="security-item" id="secDevice">
        <span class="security-badge-dot"></span>
        <span class="label">Device hygiene</span>
        <span class="detail">
          Use hardened OS when possible
        </span>
      </div>
    </div>
    <a href="security-guide.html" target="_blank" class="guide-link-btn">
      ðŸ“– Read security guide
    </a>
  </div>
</div>

<!-- Media Container (Video/Voice) -->
<div class="media-container" id="mediaContainer">
  <div class="video-grid">
    <div class="video-box remote">
      <video id="remoteVideo" autoplay playsinline></video>
      <audio id="remoteAudio" autoplay></audio>
      <div class="video-label">Peer</div>
    </div>
    <div class="video-box">
      <video id="localVideo" autoplay playsinline muted></video>
      <div class="video-label">You</div>
    </div>
  </div>
  <div class="media-controls-row">
    <button class="media-control-btn active" id="micBtn" onclick="toggleMic()">
      <span>ðŸŽ¤</span> Mic On
    </button>
    <button class="media-control-btn active" id="cameraBtn" onclick="toggleCamera()" style="display: none;">
      <span>ðŸ“¹</span> Camera On
    </button>
    <button class="media-control-btn end-btn" onclick="endSession()">
      <span>âœ•</span> End Session
    </button>
  </div>
</div>

<!-- Chat Interface -->
<div class="chat-interface" id="chatInterface">
  <div class="messages-container" id="messages"></div>
  <div class="input-area">
    <input type="text" id="messageInput" placeholder="Type message..." onkeypress="handleKeyPress(event)" />
    <button onclick="sendMessage()">Send</button>
    <button class="end-btn" onclick="endSession()">End</button>
  </div>
</div>

  </div>
</div>

<script>
  // Configuration
  const SIGNALING_SERVER = 'wss://whisper-signaling-20.ymgholdings.deno.net';

  let ws = null;
  let peerConnection = null;
  let dataChannel = null;
  let sessionCode = null;
  let isInitiator = false;
  let isPQSupported = false;

  // Media handling
  let communicationMode = 'text';
  let localStream = null;
  let micEnabled = true;
  let cameraEnabled = true;

  const config = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      {
        urls: 'turn:openrelay.metered.ca:80',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      },
      {
        urls: 'turn:openrelay.metered.ca:443',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      },
      {
        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      }
    ],
    bundlePolicy: 'max-bundle',
    rtcpMuxPolicy: 'require',
    iceTransportPolicy: 'all'
  };

  // Initialize on load
  window.addEventListener('DOMContentLoaded', () => {
    checkBrowserSupport();
    performIntegrityChecks();
  });

  function performIntegrityChecks() {
    const warnings = [];

    if (!window.isSecureContext) {
      warnings.push('âš ï¸ Not running in secure context (HTTPS required for full security)');
    }

    if (typeof window.chrome !== 'undefined' && window.chrome.runtime) {
      warnings.push('âš ï¸ Browser extension detected - ensure you trust all installed extensions');
    }

    if (!window.RTCPeerConnection) {
      warnings.push('âŒ WebRTC not available - this browser cannot establish secure P2P connections');
    }

    if (!window.crypto || !window.crypto.getRandomValues) {
      warnings.push('âŒ Crypto API not available - cannot generate secure session codes');
    }

    // Display warnings if any (optional implementation)
    if (warnings.length > 0) {
      console.warn('Security warnings:', warnings);
    }
  }

  function checkBrowserSupport() {
    const ua = navigator.userAgent;
    const pqBlocker = document.getElementById('pqBlocker');
    const secBrowser = document.getElementById('secBrowser');
    const secBrowserDetail = document.getElementById('secBrowserDetail');
    const browserHint = document.getElementById('browserHint');

    let browserName = 'Unknown';
    let version = 0;
    let pqSupport = false;

    // Detect browser
    if (ua.includes('Chrome/') || ua.includes('Edg/')) {
      const match = ua.match(/(Chrome|Edg)\/(\d+)/);
      if (match) {
        browserName = match[1] === 'Edg' ? 'Edge' : 'Chrome';
        version = parseInt(match[2]);
        pqSupport = version >= 142;
      }
    } else if (ua.includes('Firefox/')) {
      const match = ua.match(/Firefox\/(\d+)/);
      if (match) {
        browserName = 'Firefox';
        version = parseInt(match[1]);
        pqSupport = version >= 120;
      }
    } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
      browserName = 'Safari';
      pqSupport = true;
    }

    isPQSupported = pqSupport;

    if (!pqSupport) {
      pqBlocker.classList.add('active');
      secBrowser.classList.add('danger');
      secBrowserDetail.textContent = 'Current browser is not post-quantum capable';
    } else {
      secBrowser.classList.remove('warn');
      secBrowser.classList.add('ok');
      secBrowserDetail.textContent = 'Browser appears PQ-capable';
    }

    // Browser-specific hints
    if (ua.includes('Brave') || ua.includes('Tor Browser')) {
      browserHint.textContent = 'Brave or Tor detected. Excellent choice for privacy.';
    }
  }

  function updateControlsForVpn() {
    const checked = document.getElementById('vpnConfirm').checked;
    const secVpn = document.getElementById('secVpn');
    const secVpnDetail = document.getElementById('secVpnDetail');
    const btnStart = document.getElementById('btnStartSession');
    const btnJoin = document.getElementById('btnJoinSession');

    if (checked && isPQSupported) {
      secVpn.classList.remove('warn');
      secVpn.classList.add('ok');
      secVpnDetail.textContent = 'User confirmed VPN/Tor connection';
      btnStart.classList.remove('disabled');
      btnJoin.classList.remove('disabled');
    } else {
      secVpn.classList.add('warn');
      secVpn.classList.remove('ok');
      secVpnDetail.textContent = 'VPN or Tor connection not confirmed';
      btnStart.classList.add('disabled');
      btnJoin.classList.add('disabled');
    }
  }

  function selectMode(mode) {
    communicationMode = mode;
    document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('selected'));
    document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('selected');
  }

  async function setupMediaStream() {
    if (communicationMode === 'text') return;

    try {
      const constraints = {
        audio: true,
        video: communicationMode === 'video' ? {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user'
        } : false
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);

      if (communicationMode === 'video') {
        document.getElementById('localVideo').srcObject = localStream;
        document.getElementById('cameraBtn').style.display = 'inline-flex';
      } else {
        document.getElementById('cameraBtn').style.display = 'none';
      }

      if (peerConnection) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });
      }

      return localStream;
    } catch (error) {
      console.error('Error accessing media devices:', error);
      alert('Could not access camera/microphone. Please check permissions.');
      throw error;
    }
  }

  function generateSessionCode() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('').substring(0, 12).toUpperCase();
  }

  async function createSession() {
    if (document.getElementById('btnStartSession').classList.contains('disabled')) return;

    sessionCode = generateSessionCode();
    isInitiator = true;

    document.getElementById('sessionCodeGenerated').value = sessionCode;
    document.getElementById('sessionCodeRow').style.display = 'flex';
    document.getElementById('btnCopyCode').classList.remove('disabled');
    document.getElementById('waitingMessage').style.display = 'block';
    
    document.getElementById('btnStartSession').disabled = true;
    document.getElementById('btnJoinSession').disabled = true;
    document.getElementById('sessionCodeInput').disabled = true;

    if (communicationMode !== 'text') {
      try {
        await setupMediaStream();
      } catch (error) {
        resetSetupUI();
        return;
      }
    }

    connectToSignaling();
    updateStatus('Waiting for peer...', false);
  }

  async function joinSession() {
    if (document.getElementById('btnJoinSession').classList.contains('disabled')) return;

    const code = document.getElementById('sessionCodeInput').value.trim().toUpperCase();
    if (!code) {
      alert('Please enter a session code');
      return;
    }

    sessionCode = code;
    isInitiator = false;

    document.getElementById('btnStartSession').disabled = true;
    document.getElementById('btnJoinSession').disabled = true;
    document.getElementById('sessionCodeInput').disabled = true;

    if (communicationMode !== 'text') {
      try {
        await setupMediaStream();
      } catch (error) {
        resetSetupUI();
        return;
      }
    }

    connectToSignaling();
    updateStatus('Connecting to peer...', false);
  }

  function resetSetupUI() {
    document.getElementById('btnStartSession').disabled = false;
    document.getElementById('btnJoinSession').disabled = false;
    document.getElementById('sessionCodeInput').disabled = false;
    document.getElementById('sessionCodeRow').style.display = 'none';
  }

  async function copySessionCode() {
    const code = document.getElementById('sessionCodeGenerated').value;
    if (!code) return;

    try {
      await navigator.clipboard.writeText(code);
      const btn = document.getElementById('btnCopyCode');
      btn.textContent = 'Copied!';
      setTimeout(() => (btn.textContent = 'Copy'), 1600);
    } catch (e) {
      console.error('Copy failed:', e);
    }
  }

  function debugLog(message) {
    const debug = document.getElementById('debugOutput');
    if (debug) {
      debug.style.display = 'block';
      const time = new Date().toLocaleTimeString();
      debug.innerHTML += `[${time}] ${message}<br>`;
      debug.scrollTop = debug.scrollHeight;
    }
    console.log('[DEBUG]', message);
  }

  function connectToSignaling() {
    debugLog('Connecting to signaling server...');
    ws = new WebSocket(SIGNALING_SERVER);

    ws.onopen = () => {
      debugLog('WebSocket opened, sending join request');
      ws.send(JSON.stringify({
        type: 'join',
        sessionCode: sessionCode,
        isInitiator: isInitiator
      }));
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      debugLog(`Received: ${data.type}`);

      if (data.type === 'ready') {
        debugLog('Both peers connected to signaling server');
        if (isInitiator) {
          await createOffer();
        }
      } else if (data.type === 'offer') {
        debugLog('Received offer from peer');
        await handleOffer(data.offer);
      } else if (data.type === 'answer') {
        debugLog('Received answer from peer');
        await handleAnswer(data.answer);
      } else if (data.type === 'ice-candidate') {
        debugLog('Received ICE candidate');
        await handleIceCandidate(data.candidate);
      }
    };

    ws.onerror = (error) => {
      debugLog(`WebSocket error: ${error.message || 'Connection failed'}`);
      debugLog(`Attempting to connect to: ${SIGNALING_SERVER}`);
      updateStatus('Connection error - check server', false);
    };

    ws.onclose = (event) => {
      debugLog(`WebSocket closed - Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);
      if (!(dataChannel && dataChannel.readyState === 'open')) {
        updateStatus('Signaling disconnected', false);
      }
    };
  }

  async function createOffer() {
    debugLog('Creating peer connection and offer (initiator)...');
    peerConnection = new RTCPeerConnection(config);
    setupPeerConnection();

    if (localStream) {
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
        debugLog(`Added ${track.kind} track to peer connection`);
      });
    }

    dataChannel = peerConnection.createDataChannel('chat');
    setupDataChannel();
    debugLog('Data channel created');

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    debugLog('Offer created and set as local description');

    ws.send(JSON.stringify({
      type: 'offer',
      sessionCode: sessionCode,
      offer: offer
    }));
    debugLog('Offer sent to peer via signaling server');
  }

  async function handleOffer(offer) {
    debugLog('Handling offer from initiator (joiner)...');
    peerConnection = new RTCPeerConnection(config);
    setupPeerConnection();

    if (localStream) {
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
        debugLog(`Added ${track.kind} track to peer connection`);
      });
    }

    peerConnection.ondatachannel = (event) => {
      dataChannel = event.channel;
      setupDataChannel();
      debugLog('Data channel received from initiator');
    };

    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    debugLog('Remote description (offer) set');
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    debugLog('Answer created and set as local description');

    ws.send(JSON.stringify({
      type: 'answer',
      sessionCode: sessionCode,
      answer: answer
    }));
    debugLog('Answer sent to peer via signaling server');
  }

  async function handleAnswer(answer) {
    debugLog('Handling answer from joiner (initiator)...');
    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    debugLog('Remote description (answer) set - negotiation complete');
  }

  async function handleIceCandidate(candidate) {
    if (peerConnection) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
      debugLog(`ICE candidate added: ${candidate.candidate ? 'relay/srflx/host' : 'end-of-candidates'}`);
    }
  }

  function setupPeerConnection() {
    peerConnection.onicecandidate = (event) => {
      if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
        debugLog(`Sending ICE candidate: ${event.candidate.type || 'unknown'}`);
        ws.send(JSON.stringify({
          type: 'ice-candidate',
          sessionCode: sessionCode,
          candidate: event.candidate
        }));
      } else if (!event.candidate) {
        debugLog('All ICE candidates have been sent');
      }
    };

    peerConnection.ontrack = (event) => {
      if (event.track.kind === 'video') {
        const remoteVideo = document.getElementById('remoteVideo');
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
        }
      } else if (event.track.kind === 'audio') {
        const remoteAudio = document.getElementById('remoteAudio');
        if (remoteAudio.srcObject !== event.streams[0]) {
          remoteAudio.srcObject = event.streams[0];
        }
      }
    };

    peerConnection.onconnectionstatechange = () => {
      debugLog(`Connection state: ${peerConnection.connectionState} (ICE: ${peerConnection.iceConnectionState})`);
      if (peerConnection.connectionState === 'connected') {
        debugLog('P2P connection established! Switching UI...');
        checkPQEncryption();
        updateStatus('Secure P2P connection established', true);

        document.getElementById('setupInterface').style.display = 'none';
        document.getElementById('chatInterface').classList.add('active');

        if (communicationMode !== 'text') {
          document.getElementById('mediaContainer').classList.add('active');
        }

        if (ws) ws.close();
        debugLog('UI switched to chat/media interface');
      } else if (peerConnection.connectionState === 'disconnected') {
        debugLog(`âš ï¸ Connection disconnected - ICE state: ${peerConnection.iceConnectionState}`);
        updateStatus('Connection lost', false);
      } else if (peerConnection.connectionState === 'failed') {
        debugLog(`âŒ Connection failed - ICE state: ${peerConnection.iceConnectionState}`);
        updateStatus('Connection lost', false);
      } else if (peerConnection.connectionState === 'connecting') {
        debugLog(`ðŸ”„ Connection state: connecting`);
      }
    };

    peerConnection.oniceconnectionstatechange = () => {
      debugLog(`ICE connection state: ${peerConnection.iceConnectionState}`);
    };

    peerConnection.onsignalingstatechange = () => {
      debugLog(`Signaling state: ${peerConnection.signalingState}`);
    };
  }

  async function checkPQEncryption() {
    try {
      const stats = await peerConnection.getStats();
      
      let dtlsVersion = 'unknown';
      let cipherSuite = 'unknown';
      
      stats.forEach(report => {
        if (report.type === 'transport') {
          dtlsVersion = report.dtlsVersion || report.tlsVersion || 'unknown';
          cipherSuite = report.dtlsCipher || report.tlsCipher || 'unknown';
        }
      });
      
      const hasDTLS13 = dtlsVersion.includes('1.3') || dtlsVersion.includes('DTLS 1.3');
      const hasPQCipher = cipherSuite.toLowerCase().includes('kyber') || 
                         cipherSuite.toLowerCase().includes('mlkem') ||
                         cipherSuite.includes('x25519kyber768') ||
                         cipherSuite.includes('x25519mlkem768');
      
      if (hasPQCipher || (hasDTLS13 && isPQSupported)) {
        updateStatus('Post-quantum encryption active', true);
        console.log('âœ“ Post-Quantum Encryption Active');
        console.log('DTLS Version:', dtlsVersion);
        console.log('Cipher Suite:', cipherSuite);
      } else {
        console.log('âš  Using classical cryptography');
        console.log('DTLS Version:', dtlsVersion);
        console.log('Cipher Suite:', cipherSuite);
      }
    } catch (e) {
      console.log('Could not verify PQ status:', e);
    }
  }

  function setupDataChannel() {
    dataChannel.onopen = () => {
      console.log('Data channel opened');
      
      if (isInitiator) {
        setTimeout(() => {
          if (confirm('SECURITY CHECK: Did you verify the session code out-of-band?\n\n' +
                    'For maximum security, you should have:\n' +
                    'â€¢ Called your contact on a separate phone\n' +
                    'â€¢ Verbally confirmed the session code matches\n' +
                    'â€¢ Or exchanged codes in person\n\n' +
                    'This prevents man-in-the-middle attacks.\n\n' +
                    'Click OK if verified, Cancel if you want to end session.')) {
            displayMessage('âš ï¸ Session code verified out-of-band. Connection authenticated.', 'system');
          } else {
            if (confirm('End session for security? You can restart and verify properly.')) {
              endSession();
            }
          }
        }, 2000);
      }
    };

    dataChannel.onmessage = (event) => {
      displayMessage(event.data, 'received');
    };

    dataChannel.onclose = () => {
      updateStatus('Session ended - keys destroyed', false);
    };
  }

  function updateStatus(message, isSecure) {
    const pill = document.getElementById('pqStatusPill');
    const statusMain = document.getElementById('statusMain');
    const statusSub = document.getElementById('statusSub');

    if (isSecure) {
      pill.classList.add('pq-active');
      statusMain.textContent = 'Q STATUS: PQ SECURE';
      statusSub.innerHTML = 'This session is using <span>post-quantum encryption</span>';
    } else {
      pill.classList.remove('pq-active');
      statusMain.textContent = 'Q STATUS: ' + message.toUpperCase();
      statusSub.innerHTML = message;
    }
  }

  function toggleMic() {
    if (!localStream) return;

    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
      micEnabled = !micEnabled;
      audioTrack.enabled = micEnabled;

      const micBtn = document.getElementById('micBtn');
      if (micEnabled) {
        micBtn.innerHTML = '<span>ðŸŽ¤</span> Mic On';
        micBtn.classList.add('active');
        micBtn.classList.remove('muted');
      } else {
        micBtn.innerHTML = '<span>ðŸ”‡</span> Mic Off';
        micBtn.classList.remove('active');
        micBtn.classList.add('muted');
      }
    }
  }

  function toggleCamera() {
    if (!localStream || communicationMode !== 'video') return;

    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack) {
      cameraEnabled = !cameraEnabled;
      videoTrack.enabled = cameraEnabled;

      const cameraBtn = document.getElementById('cameraBtn');
      if (cameraEnabled) {
        cameraBtn.innerHTML = '<span>ðŸ“¹</span> Camera On';
        cameraBtn.classList.add('active');
        cameraBtn.classList.remove('muted');
      } else {
        cameraBtn.innerHTML = '<span>ðŸ“·</span> Camera Off';
        cameraBtn.classList.remove('active');
        cameraBtn.classList.add('muted');
      }
    }
  }

  function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();

    if (!message || !dataChannel || dataChannel.readyState !== 'open') {
      return;
    }

    dataChannel.send(message);
    displayMessage(message, 'sent');
    input.value = '';
  }

  function handleKeyPress(event) {
    if (event.key === 'Enter') {
      sendMessage();
    }
  }

  function displayMessage(text, type) {
    const messagesDiv = document.getElementById('messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ' + type;

    const time = new Date().toLocaleTimeString();
    let label = '';

    if (type === 'sent') {
      label = 'YOU';
    } else if (type === 'received') {
      label = 'PEER';
    } else if (type === 'system') {
      label = 'SYSTEM';
    }

    messageDiv.innerHTML = `
      <div class="message-meta">${time} â€¢ ${label}</div>
      <div class="message-text">${escapeHtml(text)}</div>
    `;

    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function endSession() {
    if (confirm('End session? All messages and encryption keys will be permanently destroyed.')) {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      const localVideo = document.getElementById('localVideo');
      const remoteVideo = document.getElementById('remoteVideo');
      const remoteAudio = document.getElementById('remoteAudio');
      
      if (localVideo.srcObject) {
        localVideo.srcObject.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
      }
      if (remoteVideo.srcObject) {
        remoteVideo.srcObject.getTracks().forEach(track => track.stop());
        remoteVideo.srcObject = null;
      }
      if (remoteAudio.srcObject) {
        remoteAudio.srcObject.getTracks().forEach(track => track.stop());
        remoteAudio.srcObject = null;
      }

      if (dataChannel) dataChannel.close();
      if (peerConnection) peerConnection.close();
      if (ws) ws.close();

      dataChannel = null;
      peerConnection = null;
      ws = null;
      sessionCode = null;

      location.reload();
    }
  }

  window.addEventListener('beforeunload', () => {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    if (dataChannel) dataChannel.close();
    if (peerConnection) peerConnection.close();
    if (ws) ws.close();
  });
</script>

</body>
</html>