<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WH15P3R</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        background: #000 !important;
        background-color: #000 !important;
        color: #c0c0c0;
        font-family: 'Courier New', monospace;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        padding: 20px;
    }
    
    .container {
        max-width: 800px;
        width: 100%;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        flex: 1;
    }
    
    .header {
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 1px solid #333;
        padding-bottom: 20px;
    }
    
    .header h1 {
        color: #fff;
        font-size: 32px;
        font-weight: normal;
        letter-spacing: 4px;
        margin-bottom: 10px;
    }
    
    .security-badge {
        display: inline-block;
        padding: 5px 15px;
        border: 1px solid #666;
        color: #666;
        font-size: 10px;
        letter-spacing: 1px;
        margin-top: 10px;
        transition: all 0.3s;
    }
    
    .security-badge.active {
        border-color: #00ff00;
        color: #00ff00;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }
    
    .status {
        text-align: center;
        padding: 15px;
        margin-bottom: 20px;
        border: 1px solid #333;
        font-size: 12px;
        letter-spacing: 1px;
        transition: all 0.3s;
    }
    
    .status.connected {
        border-color: #00ff00;
        color: #00ff00;
        background: rgba(0, 255, 0, 0.05);
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
    }
    
    .status.waiting {
        border-color: #ffa500;
        color: #ffa500;
    }
    
    .status.error {
        border-color: #ff0000;
        color: #ff0000;
    }
    
    .setup-panel {
        border: 1px solid #333;
        padding: 30px;
        margin-bottom: 20px;
        text-align: center;
    }
    
    .setup-panel h2 {
        color: #fff;
        font-size: 14px;
        font-weight: normal;
        margin-bottom: 25px;
        letter-spacing: 2px;
    }
    
    .big-button {
        background: #000;
        border: 2px solid #c0c0c0;
        color: #c0c0c0;
        padding: 20px 40px;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        cursor: pointer;
        letter-spacing: 3px;
        transition: all 0.3s;
        margin: 10px;
        min-width: 250px;
    }
    
    .big-button:hover {
        background: #c0c0c0;
        color: #000;
        box-shadow: 0 0 20px rgba(192, 192, 192, 0.3);
    }
    
    .big-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }
    
    .code-display {
        background: #111;
        border: 2px solid #4a9eff;
        padding: 25px;
        margin: 25px 0;
        text-align: center;
        font-size: 28px;
        letter-spacing: 5px;
        color: #4a9eff;
        word-break: break-all;
        box-shadow: 0 0 20px rgba(74, 158, 255, 0.2);
    }
    
    .input-group {
        margin: 20px 0;
    }
    
    .input-group label {
        display: block;
        font-size: 11px;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #666;
    }
    
    input[type="text"] {
        width: 100%;
        max-width: 400px;
        background: #111;
        border: 1px solid #333;
        color: #c0c0c0;
        padding: 15px;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        text-align: center;
        letter-spacing: 3px;
        transition: all 0.3s;
    }
    
    input[type="text"]:focus {
        outline: none;
        border-color: #4a9eff;
        box-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
    }
    
    button {
        background: #000;
        border: 1px solid #c0c0c0;
        color: #c0c0c0;
        padding: 12px 25px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        cursor: pointer;
        letter-spacing: 1px;
        transition: all 0.3s;
    }
    
    button:hover {
        background: #c0c0c0;
        color: #000;
    }
    
    button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }
    
    .chat-container {
        display: none;
        flex-direction: column;
        flex: 1;
        border: 2px solid #333;
        transition: all 0.5s;
    }
    
    .chat-container.active {
        display: flex;
    }
    
    .chat-container.secure {
        border-color: #00ff00;
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
    }
    
    .messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        min-height: 300px;
        max-height: 500px;
    }
    
    .message {
        margin-bottom: 15px;
        padding: 12px;
        border-left: 2px solid #333;
        padding-left: 15px;
        animation: fadeIn 0.3s;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .message.sent {
        border-left-color: #4a9eff;
    }
    
    .message.received {
        border-left-color: #00ff00;
    }
    
    .message-meta {
        font-size: 10px;
        color: #666;
        margin-bottom: 5px;
    }
    
    .message-text {
        color: #c0c0c0;
        word-wrap: break-word;
        line-height: 1.5;
    }
    
    .input-area {
        border-top: 2px solid #333;
        padding: 15px;
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    .chat-container.secure .input-area {
        border-top-color: #00ff00;
    }
    
    .input-area input {
        flex: 1;
        max-width: none;
        text-align: left;
    }
    
    .end-button {
        border-color: #ff0000;
        color: #ff0000;
    }
    
    .end-button:hover {
        background: #ff0000;
        color: #fff;
    }
    
    .instructions {
        font-size: 11px;
        line-height: 1.8;
        color: #666;
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #222;
    }
    
    .instructions strong {
        color: #c0c0c0;
    }
    
    .instructions ul {
        margin: 10px 0 10px 20px;
    }
    
    .instructions li {
        margin: 5px 0;
    }
    
    .divider {
        margin: 20px 0;
        text-align: center;
        color: #333;
        font-size: 12px;
        letter-spacing: 3px;
    }
    
    @media (max-width: 600px) {
        body {
            padding: 10px;
        }
        
        .header h1 {
            font-size: 24px;
            letter-spacing: 2px;
        }
        
        .code-display {
            font-size: 20px;
            letter-spacing: 3px;
            padding: 20px;
        }
        
        .big-button {
            min-width: 200px;
            padding: 15px 30px;
            font-size: 14px;
        }
        
        .messages {
            max-height: 400px;
        }
        
        .input-area {
            flex-wrap: wrap;
        }
        
        .input-area input {
            width: 100%;
        }
    }
</style>
```

</head>
<body style="background-color: #000;">
    <div class="container">
        <div class="header">
            <h1>WH15P3R</h1>
            <div class="security-badge" id="securityBadge">EPHEMERAL ‚Ä¢ ENCRYPTED ‚Ä¢ ANONYMOUS</div>
            <div class="security-badge" id="pqBadge" style="margin-top: 5px; border-color: #666; color: #666;">PQ STATUS: CHECKING...</div>
            <div style="margin-top: 15px;">
                <a href="USER_GUIDE.html" target="_blank" style="color: #4a9eff; text-decoration: none; font-size: 11px; letter-spacing: 1px; border: 1px solid #4a9eff; padding: 5px 15px; display: inline-block; transition: all 0.3s;" onmouseover="this.style.background='#4a9eff'; this.style.color='#000';" onmouseout="this.style.background='transparent'; this.style.color='#4a9eff';">üìñ READ SECURITY GUIDE</a>
            </div>
        </div>

```
    <div class="status" id="status">READY</div>
    
    <div id="browserWarning" style="display: none; background: #1a0000; border: 1px solid #ff6600; padding: 15px; margin-bottom: 20px; font-size: 11px; color: #ff6600;">
        <strong>‚ö† POST-QUANTUM WARNING:</strong><br>
        Your browser may not support post-quantum encryption in WebRTC. For maximum security against future quantum attacks, please use:<br>
        ‚Ä¢ Chrome/Edge 142+ (October 2025 or newer)<br>
        ‚Ä¢ Latest Firefox with DTLS 1.3 enabled<br>
        Current browser: <span id="browserInfo"></span>
    </div>
    
    <div class="setup-panel" id="setupPanel">
        <h2>ESTABLISH SECURE CHANNEL</h2>
        
        <div>
            <button class="big-button" onclick="createSession()" id="createBtn">WH15P3R CHAT</button>
        </div>
        
        <div id="sessionCodeDisplay" style="display: none;">
            <label style="color: #fff; font-size: 12px; letter-spacing: 2px;">SHARE THIS SESSION CODE:</label>
            <div class="code-display" id="sessionCode"></div>
            <p style="font-size: 12px; color: #ffa500; margin-top: 10px; letter-spacing: 1px;">
                ‚ü≥ WAITING FOR PEER CONNECTION...
            </p>
            <div style="margin-top: 15px; padding: 15px; border: 1px solid #4a9eff; background: rgba(74, 158, 255, 0.05);">
                <strong style="color: #4a9eff; font-size: 11px; letter-spacing: 1px;">üîí SECURITY RECOMMENDATION:</strong>
                <p style="font-size: 10px; color: #c0c0c0; margin-top: 8px; line-height: 1.6;">
                    <strong>Verify this code out-of-band</strong> to prevent man-in-the-middle attacks:<br>
                    ‚Ä¢ Call your contact on a separate phone line<br>
                    ‚Ä¢ Read the code aloud and verify it matches on both sides<br>
                    ‚Ä¢ Or meet in person to exchange codes<br>
                    ‚Ä¢ Do NOT share codes via insecure channels (SMS, email, social media)
                </p>
            </div>
        </div>
        
        <div class="divider">‚Äî OR ‚Äî</div>
        
        <div class="input-group">
            <label>ENTER SESSION CODE TO JOIN:</label>
            <input type="text" id="joinCode" placeholder="PASTE CODE HERE">
        </div>
        
        <div>
            <button onclick="joinSession()" id="joinBtn">JOIN SESSION</button>
        </div>
    </div>
    
    <div class="chat-container" id="chatContainer">
        <div class="messages" id="messages"></div>
        <div class="input-area">
            <input type="text" id="messageInput" placeholder="Type message..." onkeypress="handleKeyPress(event)">
            <button onclick="sendMessage()">SEND</button>
            <button class="end-button" onclick="endSession()">END</button>
        </div>
    </div>
    
    <div class="instructions">
        <strong>HOW IT WORKS:</strong>
        <ul>
            <li>Uses post-quantum cryptography (ML-KEM/Kyber hybrid) when available</li>
            <li>Each session generates unique encryption keys in DTLS 1.3 handshake</li>
            <li>No manual key exchange - WebRTC handles it automatically</li>
            <li>Messages encrypted with quantum-resistant algorithms before transmission</li>
            <li>Direct peer-to-peer connection after initial handshake</li>
            <li>When session ends, encryption keys are permanently destroyed</li>
            <li>No data stored on any server or device - ever</li>
        </ul>
        <br>
        <strong>POST-QUANTUM PROTECTION:</strong>
        <ul>
            <li>Protects against "harvest now, decrypt later" quantum attacks</li>
            <li>Requires Chrome/Edge 142+ or latest Firefox for full PQ support</li>
            <li>If both users have PQ-capable browsers, connection is quantum-safe</li>
            <li>Falls back to strong classical crypto if PQ unavailable</li>
            <li>Look for "üîí Q POST-QUANTUM ACTIVE" badge when connected</li>
        </ul>
        <br>
        <strong>RECOMMENDED SECURITY PRACTICES:</strong>
        <ul>
            <li><strong>Use Tor Browser</strong> - Hides your IP address from both server and chat partner</li>
            <li><strong>Hardened Devices:</strong> GrapheneOS (Android), Tails OS (desktop), or hardened Linux</li>
            <li><strong>Verify Session Code:</strong> Confirm code out-of-band (phone call, in-person) to prevent man-in-the-middle</li>
            <li><strong>Public WiFi:</strong> Access from coffee shops, libraries - never use home internet for sensitive chats</li>
            <li><strong>Close Immediately:</strong> End session and close browser as soon as conversation finishes</li>
            <li><strong>No Screenshots:</strong> Never capture or save messages - they exist only in this session</li>
        </ul>
        <br>
        <strong>DEFENSE AGAINST STATE-LEVEL THREATS:</strong>
        <ul>
            <li><strong>Best Practice:</strong> Use Tails OS booted from USB (leaves zero traces on device)</li>
            <li><strong>Mobile:</strong> Use GrapheneOS or CalyxOS with hardened browser settings</li>
            <li><strong>Out-of-Band Verification:</strong> Call your contact and verbally confirm the session code matches</li>
            <li><strong>Timing:</strong> Vary when and where you access - avoid patterns</li>
            <li><strong>Operational Security:</strong> Assume devices may be compromised - discuss sensitive topics in person when possible</li>
            <li><strong>Physical Security:</strong> Use devices only for secure communications, keep in Faraday bag when not in use</li>
        </ul>
        <br>
        <strong>CRITICAL LIMITATIONS:</strong>
        <ul>
            <li>‚ùå <strong>Cannot protect against compromised devices</strong> - If malware/keyloggers are on your device, encryption cannot help</li>
            <li>‚ùå <strong>Cannot protect against screen recording</strong> - Messages are visible on screen after decryption</li>
            <li>‚ùå <strong>Cannot hide metadata</strong> - Timing and frequency of communications may be observable</li>
            <li>‚ùå <strong>Cannot protect against physical coercion</strong> - Rubber-hose cryptanalysis defeats all encryption</li>
            <li>‚úÖ <strong>DOES protect message content</strong> - Even future quantum computers cannot decrypt your messages</li>
            <li>‚úÖ <strong>DOES protect against server seizure</strong> - No messages ever stored anywhere</li>
        </ul>
        <br>
        <strong>‚ö†Ô∏è UNDERSTAND THE THREAT MODEL:</strong><br>
        This system provides <strong>quantum-resistant transport encryption</strong> and <strong>zero storage</strong>. It is excellent protection against network surveillance and future quantum attacks. However, <strong>no cryptography can protect against endpoint compromise</strong>. If an adversary controls your device (malware, hardware implants, firmware backdoors), they can read messages before encryption or after decryption. For highest-risk scenarios: use air-gapped devices, meet in person for critical discussions, and assume digital communications are monitored. This tool is one layer in defense-in-depth, not a magic solution.
    </div>
</div>

<script>
    // Configuration - UPDATE THIS WITH YOUR SIGNALING SERVER
    const SIGNALING_SERVER = 'ws://localhost:3000'; // Change to wss://your-domain.com
    
    let ws = null;
    let peerConnection = null;
    let dataChannel = null;
    let sessionCode = null;
    let isInitiator = false;
    let isPQSupported = false;
    
    // Enhanced RTCConfiguration for DTLS 1.3 and PQ support
    const config = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun1.l.google.com:19302' }
        ],
        // Prefer DTLS 1.3 for PQ support
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
    };
    
    // Check browser PQ support on load
    window.addEventListener('DOMContentLoaded', () => {
        checkBrowserSupport();
        performIntegrityChecks();
    });
    
    function performIntegrityChecks() {
        const warnings = [];
        
        // Check if running in secure context
        if (!window.isSecureContext) {
            warnings.push('‚ö†Ô∏è Not running in secure context (HTTPS required for full security)');
        }
        
        // Check for debugging/developer tools
        if (typeof window.chrome !== 'undefined' && window.chrome.runtime) {
            // Running in extension context - could be modified
            warnings.push('‚ö†Ô∏è Browser extension detected - ensure you trust all installed extensions');
        }
        
        // Check for suspicious APIs that might indicate compromise
        const suspiciousAPIs = [];
        if (typeof window.external !== 'undefined') suspiciousAPIs.push('window.external');
        if (typeof window.__proto__.constructor !== 'function') suspiciousAPIs.push('modified prototype');
        
        if (suspiciousAPIs.length > 0) {
            warnings.push('‚ö†Ô∏è Unusual browser APIs detected: ' + suspiciousAPIs.join(', '));
        }
        
        // Check WebRTC is available
        if (!window.RTCPeerConnection) {
            warnings.push('‚ùå WebRTC not available - this browser cannot establish secure P2P connections');
        }
        
        // Check crypto API
        if (!window.crypto || !window.crypto.getRandomValues) {
            warnings.push('‚ùå Crypto API not available - cannot generate secure session codes');
        }
        
        // Display warnings if any
        if (warnings.length > 0) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = 'background:#1a0000;border:2px solid #ff0000;padding:20px;margin:20px 0;';
            warningDiv.innerHTML = '<strong style="color:#ff0000;">SECURITY WARNINGS:</strong><br>' +
                warnings.map(w => '<div style="color:#ff6600;margin:5px 0;font-size:11px;">' + w + '</div>').join('');
            document.querySelector('.container').insertBefore(warningDiv, document.querySelector('.header'));
        }
    }
    
    function checkBrowserSupport() {
        const ua = navigator.userAgent;
        const pqBadge = document.getElementById('pqBadge');
        const browserWarning = document.getElementById('browserWarning');
        const browserInfo = document.getElementById('browserInfo');
        
        // Detect browser and version
        let browserName = 'Unknown';
        let version = 0;
        let pqSupport = false;
        
        // Chrome/Chromium/Edge detection
        if (ua.includes('Chrome/') || ua.includes('Edg/')) {
            const match = ua.match(/(Chrome|Edg)\/(\d+)/);
            if (match) {
                browserName = match[1] === 'Edg' ? 'Edge' : 'Chrome';
                version = parseInt(match[2]);
                pqSupport = version >= 142; // PQ in WebRTC since Chrome 142
            }
        }
        // Firefox detection
        else if (ua.includes('Firefox/')) {
            const match = ua.match(/Firefox\/(\d+)/);
            if (match) {
                browserName = 'Firefox';
                version = parseInt(match[1]);
                // Firefox has DTLS 1.3, PQ support likely in recent versions
                pqSupport = version >= 120; // Conservative estimate
            }
        }
        // Safari detection
        else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
            browserName = 'Safari';
            pqSupport = true; // Safari has PQ in TLS, DTLS status unclear
        }
        
        browserInfo.textContent = `${browserName} ${version || 'unknown version'}`;
        isPQSupported = pqSupport;
        
        if (pqSupport) {
            pqBadge.textContent = 'üîí POST-QUANTUM READY';
            pqBadge.style.borderColor = '#00ff00';
            pqBadge.style.color = '#00ff00';
            browserWarning.style.display = 'none';
        } else {
            pqBadge.textContent = '‚ö† PQ NOT SUPPORTED';
            pqBadge.style.borderColor = '#ff6600';
            pqBadge.style.color = '#ff6600';
            browserWarning.style.display = 'block';
        }
    }
    
    function updateStatus(message, type = '') {
        const status = document.getElementById('status');
        status.textContent = message;
        status.className = 'status ' + type;
    }
    
    function generateSessionCode() {
        const array = new Uint8Array(16);
        crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('').substring(0, 12).toUpperCase();
    }
    
    async function createSession() {
        sessionCode = generateSessionCode();
        isInitiator = true;
        
        document.getElementById('sessionCode').textContent = sessionCode;
        document.getElementById('sessionCodeDisplay').style.display = 'block';
        document.getElementById('createBtn').disabled = true;
        document.getElementById('joinBtn').disabled = true;
        document.getElementById('joinCode').disabled = true;
        
        connectToSignaling();
        updateStatus('‚ü≥ WAITING FOR PEER...', 'waiting');
    }
    
    function joinSession() {
        const code = document.getElementById('joinCode').value.trim().toUpperCase();
        if (!code) {
            alert('Please enter a session code');
            return;
        }
        
        sessionCode = code;
        isInitiator = false;
        
        document.getElementById('createBtn').disabled = true;
        document.getElementById('joinBtn').disabled = true;
        document.getElementById('joinCode').disabled = true;
        
        connectToSignaling();
        updateStatus('‚ü≥ CONNECTING TO PEER...', 'waiting');
    }
    
    function connectToSignaling() {
        ws = new WebSocket(SIGNALING_SERVER);
        
        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'join',
                sessionCode: sessionCode,
                isInitiator: isInitiator
            }));
        };
        
        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            
            if (data.type === 'ready') {
                if (isInitiator) {
                    await createOffer();
                }
            } else if (data.type === 'offer') {
                await handleOffer(data.offer);
            } else if (data.type === 'answer') {
                await handleAnswer(data.answer);
            } else if (data.type === 'ice-candidate') {
                await handleIceCandidate(data.candidate);
            }
        };
        
        ws.onerror = () => {
            updateStatus('‚ö† CONNECTION ERROR - CHECK SERVER', 'error');
        };
        
        ws.onclose = () => {
            if (dataChannel && dataChannel.readyState === 'open') {
                // P2P is established, signaling close is normal
            } else {
                updateStatus('‚ö† SIGNALING DISCONNECTED', 'error');
            }
        };
    }
    
    async function createOffer() {
        peerConnection = new RTCPeerConnection(config);
        setupPeerConnection();
        
        dataChannel = peerConnection.createDataChannel('chat');
        setupDataChannel();
        
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        ws.send(JSON.stringify({
            type: 'offer',
            sessionCode: sessionCode,
            offer: offer
        }));
    }
    
    async function handleOffer(offer) {
        peerConnection = new RTCPeerConnection(config);
        setupPeerConnection();
        
        peerConnection.ondatachannel = (event) => {
            dataChannel = event.channel;
            setupDataChannel();
        };
        
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        ws.send(JSON.stringify({
            type: 'answer',
            sessionCode: sessionCode,
            answer: answer
        }));
    }
    
    async function handleAnswer(answer) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }
    
    async function handleIceCandidate(candidate) {
        if (peerConnection) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
    }
    
    function setupPeerConnection() {
        peerConnection.onicecandidate = (event) => {
            if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'ice-candidate',
                    sessionCode: sessionCode,
                    candidate: event.candidate
                }));
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            if (peerConnection.connectionState === 'connected') {
                // Check if PQ encryption is actually being used
                checkPQEncryption();
                
                updateStatus('‚úì SECURE P2P CONNECTION ESTABLISHED', 'connected');
                document.getElementById('securityBadge').classList.add('active');
                document.getElementById('chatContainer').classList.add('secure');
                if (ws) ws.close();
            } else if (peerConnection.connectionState === 'disconnected' || 
                       peerConnection.connectionState === 'failed') {
                updateStatus('‚ö† CONNECTION LOST', 'error');
                document.getElementById('securityBadge').classList.remove('active');
                document.getElementById('chatContainer').classList.remove('secure');
            }
        };
    }
    
    async function checkPQEncryption() {
        try {
            const stats = await peerConnection.getStats();
            const pqBadge = document.getElementById('pqBadge');
            
            let dtlsVersion = 'unknown';
            let cipherSuite = 'unknown';
            
            stats.forEach(report => {
                if (report.type === 'transport') {
                    dtlsVersion = report.dtlsVersion || report.tlsVersion || 'unknown';
                    cipherSuite = report.dtlsCipher || report.tlsCipher || 'unknown';
                }
            });
            
            // Check for DTLS 1.3 or PQ indicators
            const hasDTLS13 = dtlsVersion.includes('1.3') || dtlsVersion.includes('DTLS 1.3');
            const hasPQCipher = cipherSuite.toLowerCase().includes('kyber') || 
                               cipherSuite.toLowerCase().includes('mlkem') ||
                               cipherSuite.includes('x25519kyber768') ||
                               cipherSuite.includes('x25519mlkem768');
            
            if (hasPQCipher || (hasDTLS13 && isPQSupported)) {
                pqBadge.textContent = 'üîí Q POST-QUANTUM ACTIVE';
                pqBadge.style.borderColor = '#00ff00';
                pqBadge.style.color = '#00ff00';
                pqBadge.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.3)';
                
                // Log for debugging
                console.log('‚úì Post-Quantum Encryption Active');
                console.log('DTLS Version:', dtlsVersion);
                console.log('Cipher Suite:', cipherSuite);
            } else {
                pqBadge.textContent = '‚ö† CLASSIC CRYPTO ONLY';
                pqBadge.style.borderColor = '#ffa500';
                pqBadge.style.color = '#ffa500';
                
                console.log('‚ö† Using classical cryptography');
                console.log('DTLS Version:', dtlsVersion);
                console.log('Cipher Suite:', cipherSuite);
            }
        } catch (e) {
            console.log('Could not verify PQ status:', e);
        }
    }
    
    function setupDataChannel() {
        dataChannel.onopen = () => {
            document.getElementById('setupPanel').style.display = 'none';
            document.getElementById('chatContainer').classList.add('active');
            document.getElementById('chatContainer').classList.add('secure');
            updateStatus('‚úì SECURE P2P CONNECTION ESTABLISHED', 'connected');
            document.getElementById('securityBadge').classList.add('active');
            document.getElementById('messageInput').focus();
            
            // Prompt for out-of-band verification
            if (isInitiator) {
                setTimeout(() => {
                    if (confirm('SECURITY CHECK: Did you verify the session code out-of-band?\n\n' +
                              'For maximum security, you should have:\n' +
                              '‚Ä¢ Called your contact on a separate phone\n' +
                              '‚Ä¢ Verbally confirmed the session code matches\n' +
                              '‚Ä¢ Or exchanged codes in person\n\n' +
                              'This prevents man-in-the-middle attacks.\n\n' +
                              'Click OK if verified, Cancel if you want to end session.')) {
                        displayMessage('‚ö†Ô∏è Session code verified out-of-band. Connection authenticated.', 'system');
                    } else {
                        if (confirm('End session for security? You can restart and verify properly.')) {
                            endSession();
                        }
                    }
                }, 2000);
            }
        };
        
        dataChannel.onmessage = (event) => {
            displayMessage(event.data, 'received');
        };
        
        dataChannel.onclose = () => {
            updateStatus('‚ö† SESSION ENDED - KEYS DESTROYED', 'error');
            document.getElementById('securityBadge').classList.remove('active');
            document.getElementById('chatContainer').classList.remove('secure');
        };
    }
    
    function sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (!message || !dataChannel || dataChannel.readyState !== 'open') {
            return;
        }
        
        dataChannel.send(message);
        displayMessage(message, 'sent');
        input.value = '';
    }
    
    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }
    
    function displayMessage(text, type) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ' + type;
        
        const time = new Date().toLocaleTimeString();
        let label = '';
        
        if (type === 'sent') {
            label = 'YOU';
        } else if (type === 'received') {
            label = 'PEER';
        } else if (type === 'system') {
            label = 'SYSTEM';
            messageDiv.style.borderLeftColor = '#4a9eff';
            messageDiv.style.background = 'rgba(74, 158, 255, 0.05)';
        }
        
        messageDiv.innerHTML = `
            <div class="message-meta">${time} ‚Ä¢ ${label}</div>
            <div class="message-text">${escapeHtml(text)}</div>
        `;
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function endSession() {
        if (confirm('End session? All messages and encryption keys will be permanently destroyed.')) {
            if (dataChannel) dataChannel.close();
            if (peerConnection) peerConnection.close();
            if (ws) ws.close();
            
            // Force cleanup
            dataChannel = null;
            peerConnection = null;
            ws = null;
            sessionCode = null;
            
            location.reload();
        }
    }
    
    // Clear everything on page unload
    window.addEventListener('beforeunload', () => {
        if (dataChannel) dataChannel.close();
        if (peerConnection) peerConnection.close();
        if (ws) ws.close();
    });
</script>
```

</body>
</html>